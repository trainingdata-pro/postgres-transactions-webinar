-- Repeatable Read

-- 1. Отсутствие неповторяющегося и фантомного чтения.

-- Само название уровня изоляции Repeatable Read говорит о повторяемости чтения.
-- Проверим это, а заодно убедимся и в отсутствии фантомов.

-- Шаг 1.1 =>
-- Для этого в первой транзакции вернем счета Боба в прежнее состояние и создадим новый счет для Чарли:
BEGIN;
UPDATE accounts SET amount = 200.00 WHERE id = 2;
UPDATE accounts SET amount = 800.00 WHERE id = 3;
INSERT INTO accounts VALUES
(4, 'charlie', 100.00);
SELECT * FROM accounts ORDER BY id;

-- Шаг 1.3 =>
-- Теперь первая транзакция фиксирует изменения, а вторая повторно выполняет тот же самый запрос
COMMIT;

------------------------------------------------------------------------------------------------------------------------

-- 2. Ошибка сериализации вместо потерянных изменений.

-- Как мы уже видели, на уровне изоляции Read Committed при обновлении одной и той же строки
-- двумя транзакциями может возникнуть аномалия несогласованного чтения.
-- Это происходит из-за того, что ожидающая транзакция перечитывает заблокированную строку и
-- видит ее на один момент времени, а остальные строки выборки — на другой.
-- На уровне Repeatable Read такая аномалия не допускается, но, если она всё-таки возникает,
-- сделать уже ничего нельзя — поэтому транзакция обрывается с ошибкой сериализации.
-- Проверим, повторив тот же сценарий с процентами:

-- Шаг 2.1
-- Сейчас у Боба 1000 ₽ на двух счетах
SELECT *
FROM accounts
WHERE client = 'bob';

-- Начинаем транзакцию, которая уменьшает баланс Боба
-- Шаг 2.2 =>
BEGIN;
UPDATE accounts SET amount = amount - 100 WHERE id = 3;

-- Шаг 2.4 =>
-- Между тем первая транзакция фиксирует изменения
COMMIT;
-- Шаг 2.6
-- Данные остались согласованными:
SELECT *
FROM accounts
WHERE client = 'bob';
-- Такая же ошибка будет и в случае любого другого конкурентного изменения строки,
-- даже если оно не затрагивает интересующие нас столбцы.

-- Можно проверить, что и сценарий с приложениями, обновляющими баланс на основе запомненного значения,
-- приводит к той же ошибке:
-- Шаг 2.7 =>
BEGIN ISOLATION LEVEL REPEATABLE READ;
SELECT amount FROM accounts WHERE id = 1;

-- Шаг 2.9 =>
UPDATE accounts SET amount = 900.00 + 100.00 WHERE id = 1 RETURNING amount;
COMMIT;

-- Практический вывод: если приложение использует уровень изоляции Repeatable Read для пишущих транзакций,
-- оно должно быть готово повторять транзакции, завершившиеся ошибкой сериализации.
-- Для только читающих транзакций такой исход невозможен.

------------------------------------------------------------------------------------------------------------------------

-- 3. Несогласованная запись.
-- Итак, в PostgreSQL на уровне изоляции Repeatable Read предотвращаются все аномалии, описанные в стандарте.
-- Но не все вообще — науке до сих пор неизвестно, сколько их существует. Однако доказан важный факт:
-- изоляция на основе снимков оставляет возможными ровно две аномалии, сколько бы их ни было всего.
-- Первая из этих аномалий — несогласованная запись (write skew).

-- Пусть действует такое правило согласованности: допускаются отрицательные суммы на отдельных счетах клиента,
-- если общая сумма на всех счетах этого клиента остается неотрицательной.
-- Первая транзакция получает сумму на счетах Боба:

-- Шаг 3.1 =>
BEGIN ISOLATION LEVEL REPEATABLE READ;
SELECT sum(amount) FROM accounts WHERE client = 'bob';

-- Шаг 3.3 =>
-- Первая транзакция справедливо полагает, что сумму одного из счетов можно уменьшить на 600 ₽:
UPDATE accounts SET amount = amount - 600.00 WHERE id = 2;

-- Шаг 3.5 =>
COMMIT;
SELECT * FROM accounts WHERE client = 'bob';

-- У нас получилось увести баланс Боба в минус, хотя поодиночке каждая из транзакций отработала бы корректно.

------------------------------------------------------------------------------------------------------------------------


-- 4. Аномалия только читающей транзакции.

-- Аномалия только читающей транзакции — вторая и последняя из аномалий, возможных на уровне Repeatable Read.
-- Чтобы продемонстрировать ее, потребуются три транзакции, две из которых будут изменять данные,
-- а третья — только читать.

-- Но сначала восстановим состояние счетов Боба:
UPDATE accounts SET amount = 900.00 WHERE id = 2;
SELECT * FROM accounts WHERE client = 'bob';

-- Шаг 4.1 =>
-- Первая транзакция начисляет Бобу проценты на сумму средств на всех счетах.
-- Проценты зачисляются на один из его счетов:
BEGIN ISOLATION LEVEL REPEATABLE READ;
UPDATE accounts SET amount = amount + (
SELECT sum(amount) FROM accounts WHERE client = 'bob' ) * 0.01
WHERE id = 2;

-- И только после этого первая транзакция завершается:
COMMIT;
-- => 3